 Please keep all files related to a homework or an assignment within the appropriate directory. Files checked in outside of specific homework or assignment directory will not be reviewed or graded for that homework/assignment.

Check in and modify files as many times as you like. You will not be able to modify the files after the deadline.

You will work as a pair, both of you are responsible for the completed work in all assignments and homework. Reasonable effort is expected from each person. If you do not check in, you will not receive any scores. When pairing please switch who checks in so there is significant number of check in from each of you.

The deadlines are strict, there will be no extensions. Don't email any code to Venkat or to the mailing list. Your last check in before the deadline will be graded. If your last check in breaks the code, both you and your pair will lose significant points.

Please feel free to ask for frequent reviews. See the reviews/readme.txt file for details on how to ask for reviews.

You can evolve the answers and solutions based on the reviews. Only the latest checkin at the time of review will be looked at. Also the final check in will be the only one graded.

You are still responsible to successfully complete an homework or assignment even if your pair is a no-show. You can request to change pairs at any time and if there is another person in the class willing to pair with you we can make the switch.

A lot of help will be provided in this course, but you have to start early and ask for help along the way.                                          

Please read the academic honesty policy posted on the course mailing list.                   

The above details apply to all homework and assignments in this course.                   

Now to homework #1.
==============================================================================
HW1: Due 11:59PM CT February 2

Q1. What's simple design?

A simple design contains the minimal amount of detail or code that meets the requirements or executes its intended purpose. One important step in creating a simple design is researching and gathering requirements. This step is rather difficult as all ideas and requirements would not be fully known at the beginning.

Simple designs have the ability to easily evolve and adapt through the whole software development lifecycle. The inherent clarity and minimalism lays the groundwork for easy comprehension and modification in a simple design. As requirements and ideas inevitably shift, a simple design becomes a flexible framework that assists swift and efficient adjustments.

Additionally if a simple design were to fail, it would be easy to identify these failures and resolve them. Simple designs are not as closely connected as complex designs, so when there is a failure in one portion of the design, the developer can easily go back and resolve the failure without affecting the rest of the design.

Q2. Why should design be simple?

Straightforward code will help developers focus on the essential aspect of the system and foster a more efficient development process. When code is clear and simple, developers can easily understand the logic and functionality of a system without getting bogged down by unnecessary intricacy. This clarity will allow developers to allocate their resources more efficiently and focus more on critical components such as software design, business logic, and algorithm at hand.

Simplicity will keep any changes affordable and reliable for the future. The ease of maintenance will reduce the chances of errors or bugs and minimize the complexity of the intricate system. In short, the simplicity in design will invest in the success and long-term sustainability of the design.

A simple design will also greatly benefit the end users. A software ultimately should be easy to navigate for the end user while providing all the necessary information and functions for it. A simple design is perfect for that role, the simplicity will make it easy to navigate while only containing the essential details and functions.

Although a simple design may be harder to develop and take much more time and money to develop than a complex design, overall a simple design will be more time and cost effective. Simple designs make it easier to add new features, to evolve, to change and to maintain, unlike complex designs where adding any changes to one portion of the design can affect other parts of the design, which can cause the developer to go back and rewrite the design. Simple designs therefore cost less time and money in the long run.

Another benefit for making simple designs is the ease of collaboration. The clarity in a straightforward design serves as a common language to promote communication and collaborative problem solving. Furthermore, simplicity facilitates a shared understanding of the system’s architecture and this shared comprehension enhances the efficiency of the team. Thus, enabling seamless collaboration on coding tasks and the collective pursuit of project goals.
 
Simple designs can lower the cost against potential failures in the software and financially. The clarity and transparency ensures to identify and resolve issues during the development process. When problems occur, the simplicity of the design accelerates debugging and troubleshootings problems, which reduces the time, resources, and money required for issue resolutions.  

Q3. In your experience, from what you've seen, has there been problems with design not being simple or benefits from it being simple? Give examples of situations and impact. Discuss.

Uyen Vi Phan
Unnecessarily complex designs can make it more difficult for the developer to modify the design in the future. For example, once I had an assignment that involved creating a Binary Search Tree. I remember I made one previously for an earlier assignment that semester, so I went back and attempted to modify it to meet the requirements for my new assignment. However, due to the amount of unnecessary and poorly named variables, I had to start all over because it was too difficult to understand.

My algorithms class last semester presented simple functions in order to show how backtracking works. The functions only had a few lines of code and only included the bare components to show how the backtracking works. I was able to understand how backtracking works and how to write one because it excluded all the unnecessary details and focused on the most relevant components to backtracking.

Enlai Yii
Complex designs can make comprehension and modification difficult for mentors and developers. For example, from my role as a teaching assistant, one of my student’s intricate Tamagotchi game implementations, created with single-letter variable names and multiple base classes. The complex code proved challenging, not only was the code not readable, but also rendered the system unusable after attempting to add one feature. This example highlights the importance of simplicity of adaptability and maintainability from a simple software design.

For simple designs, the ease of collaboration is one of the benefits of simplicity. For example, in my recent summer employment with Johns Hopkins CTY, I was working on a computer network to keep track of every computer on campus. I needed assistance with optimizing my system, so I asked one of the computer science instructors, he read and understood the simple design, and he changed the data structure I implemented. The situation supports how simple designs promote the ease of collaboration. 

Another benefit of simple designs is lowering the cost of failure. While developing my personal website, researching and gathering my requirements was essential for the start of the project. With the basic requirements, the design evolved with ease through the multiple implementations and new features, and the project was completed successfully. The example demonstrates how gathering requirements, one of the steps for a simple design, decreased the cost of failure of the project and increased the chances of success. 

Total [10]: 10

Please see <https://groups.google.com/g/uhcss24sd/c/CnLUac-Cskg/m/28h0-o5UAgAJ>
